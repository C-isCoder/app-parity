// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/data/drug.proto

package api_service_v1

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	_ "github.com/golang/protobuf/ptypes/empty"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// 搜索请求参数
type SearchReq struct {
	// 关键字
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty" form:"key" validate:"required"`
	// 一页数量
	PageSize int32 `protobuf:"varint,2,opt,name=pageSize,proto3" json:"pageSize" form:"pageSize"validate:"required"`
	// 第几页
	PageNum              int32    `protobuf:"varint,3,opt,name=pageNum,proto3" json:"pageNum" form:"pageNum"validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SearchReq) Reset()         { *m = SearchReq{} }
func (m *SearchReq) String() string { return proto.CompactTextString(m) }
func (*SearchReq) ProtoMessage()    {}
func (*SearchReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_f09b63fbd454f679, []int{0}
}
func (m *SearchReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchReq.Merge(m, src)
}
func (m *SearchReq) XXX_Size() int {
	return m.Size()
}
func (m *SearchReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchReq.DiscardUnknown(m)
}

var xxx_messageInfo_SearchReq proto.InternalMessageInfo

// 搜索返回参数
type SearchResp struct {
	// 符合结果总数
	Count int32 `protobuf:"varint,1,opt,name=count,proto3" json:"count"`
	// 当前搜索结果列表
	Drugs                []*Drug  `protobuf:"bytes,2,rep,name=drugs,proto3" json:"drugs"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SearchResp) Reset()         { *m = SearchResp{} }
func (m *SearchResp) String() string { return proto.CompactTextString(m) }
func (*SearchResp) ProtoMessage()    {}
func (*SearchResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_f09b63fbd454f679, []int{1}
}
func (m *SearchResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchResp.Merge(m, src)
}
func (m *SearchResp) XXX_Size() int {
	return m.Size()
}
func (m *SearchResp) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchResp.DiscardUnknown(m)
}

var xxx_messageInfo_SearchResp proto.InternalMessageInfo

// 药品列表请求参数
type DrugsReq struct {
	// 一页数量
	PageSize int32 `protobuf:"varint,1,opt,name=pageSize,proto3" json:"pageSize"`
	// 第几页
	PageNum              int32    `protobuf:"varint,2,opt,name=pageNum,proto3" json:"pageNum"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DrugsReq) Reset()         { *m = DrugsReq{} }
func (m *DrugsReq) String() string { return proto.CompactTextString(m) }
func (*DrugsReq) ProtoMessage()    {}
func (*DrugsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_f09b63fbd454f679, []int{2}
}
func (m *DrugsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DrugsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DrugsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DrugsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DrugsReq.Merge(m, src)
}
func (m *DrugsReq) XXX_Size() int {
	return m.Size()
}
func (m *DrugsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DrugsReq.DiscardUnknown(m)
}

var xxx_messageInfo_DrugsReq proto.InternalMessageInfo

// 药品列表返回参数
type DrugsResp struct {
	// 药品列表数据
	Drugs                []*Drug  `protobuf:"bytes,1,rep,name=drugs,proto3" json:"drugs"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DrugsResp) Reset()         { *m = DrugsResp{} }
func (m *DrugsResp) String() string { return proto.CompactTextString(m) }
func (*DrugsResp) ProtoMessage()    {}
func (*DrugsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_f09b63fbd454f679, []int{3}
}
func (m *DrugsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DrugsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DrugsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DrugsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DrugsResp.Merge(m, src)
}
func (m *DrugsResp) XXX_Size() int {
	return m.Size()
}
func (m *DrugsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_DrugsResp.DiscardUnknown(m)
}

var xxx_messageInfo_DrugsResp proto.InternalMessageInfo

// 药品
type Drug struct {
	// 一级类别ID
	Level0 int32 `protobuf:"varint,1,opt,name=level0,proto3" json:"level0,omitempty"`
	// 二级类别ID
	Level1 int32 `protobuf:"varint,2,opt,name=level1,proto3" json:"level1,omitempty"`
	// 三级类别ID
	Level2 int32 `protobuf:"varint,3,opt,name=level2,proto3" json:"level2,omitempty"`
	// id
	WholesaleId int32 `protobuf:"varint,4,opt,name=wholesaleId,proto3" json:"wholesaleId,omitempty"`
	// 名称
	DrugName string `protobuf:"bytes,5,opt,name=drugName,proto3" json:"drugName,omitempty"`
	// 供货商 ID
	ProviderId int32 `protobuf:"varint,6,opt,name=providerId,proto3" json:"providerId,omitempty"`
	// 供货商名称
	ProviderName string `protobuf:"bytes,7,opt,name=providerName,proto3" json:"providerName,omitempty"`
	// 规格
	Specification string `protobuf:"bytes,8,opt,name=specification,proto3" json:"specification,omitempty"`
	// 单位
	Unit string `protobuf:"bytes,9,opt,name=unit,proto3" json:"unit,omitempty"`
	// 生产商
	Manufacturer string `protobuf:"bytes,10,opt,name=manufacturer,proto3" json:"manufacturer,omitempty"`
	// 批号
	ApprovalNumber string `protobuf:"bytes,11,opt,name=approvalNumber,proto3" json:"approvalNumber,omitempty"`
	// 有效期
	ValidDate string `protobuf:"bytes,12,opt,name=validDate,proto3" json:"validDate,omitempty"`
	// 原价
	ChainPrice string `protobuf:"bytes,13,opt,name=chainPrice,proto3" json:"chainPrice,omitempty"`
	// 折扣价
	DisPrice string `protobuf:"bytes,14,opt,name=disPrice,proto3" json:"disPrice,omitempty"`
	// 最低价
	MinPrice string `protobuf:"bytes,15,opt,name=minPrice,proto3" json:"minPrice,omitempty"`
	// 最高价
	MaxPrice string `protobuf:"bytes,16,opt,name=maxPrice,proto3" json:"maxPrice,omitempty"`
	// 旧价格
	OldPrice string `protobuf:"bytes,17,opt,name=oldPrice,proto3" json:"oldPrice,omitempty"`
	// 抢购价
	Price                string   `protobuf:"bytes,18,opt,name=price,proto3" json:"price,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Drug) Reset()         { *m = Drug{} }
func (m *Drug) String() string { return proto.CompactTextString(m) }
func (*Drug) ProtoMessage()    {}
func (*Drug) Descriptor() ([]byte, []int) {
	return fileDescriptor_f09b63fbd454f679, []int{4}
}
func (m *Drug) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Drug) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Drug.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Drug) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Drug.Merge(m, src)
}
func (m *Drug) XXX_Size() int {
	return m.Size()
}
func (m *Drug) XXX_DiscardUnknown() {
	xxx_messageInfo_Drug.DiscardUnknown(m)
}

var xxx_messageInfo_Drug proto.InternalMessageInfo

func init() {
	proto.RegisterType((*SearchReq)(nil), "api.service.v1.SearchReq")
	proto.RegisterType((*SearchResp)(nil), "api.service.v1.SearchResp")
	proto.RegisterType((*DrugsReq)(nil), "api.service.v1.DrugsReq")
	proto.RegisterType((*DrugsResp)(nil), "api.service.v1.DrugsResp")
	proto.RegisterType((*Drug)(nil), "api.service.v1.Drug")
}

func init() { proto.RegisterFile("api/data/drug.proto", fileDescriptor_f09b63fbd454f679) }

var fileDescriptor_f09b63fbd454f679 = []byte{
	// 620 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x94, 0x41, 0x6f, 0xd3, 0x30,
	0x14, 0xc7, 0x97, 0xad, 0xdd, 0x5a, 0x77, 0x1b, 0x60, 0x26, 0x64, 0x8d, 0x29, 0x29, 0x11, 0xa0,
	0x5e, 0x68, 0xb7, 0x02, 0x97, 0x1d, 0xab, 0x5d, 0xc6, 0xa1, 0x42, 0xdd, 0x0d, 0x4e, 0x6e, 0xf2,
	0x9a, 0x5a, 0x4b, 0xe2, 0xcc, 0x49, 0x0a, 0xe3, 0x93, 0x20, 0x3e, 0xd1, 0x8e, 0xfb, 0x02, 0x54,
	0x6c, 0xdc, 0x76, 0xdc, 0x27, 0x40, 0x7e, 0x4e, 0xda, 0x74, 0xda, 0x85, 0x53, 0xfc, 0xff, 0xff,
	0xde, 0x7b, 0xf6, 0x7b, 0xb6, 0x42, 0x9e, 0xf3, 0x44, 0xf4, 0x7c, 0x9e, 0xf1, 0x9e, 0xaf, 0xf2,
	0xa0, 0x9b, 0x28, 0x99, 0x49, 0xba, 0xcb, 0x13, 0xd1, 0x4d, 0x41, 0xcd, 0x84, 0x07, 0xdd, 0xd9,
	0xd1, 0xfe, 0xbb, 0x40, 0x64, 0xd3, 0x7c, 0xdc, 0xf5, 0x64, 0xd4, 0x0b, 0x64, 0x20, 0x7b, 0x18,
	0x36, 0xce, 0x27, 0xa8, 0x50, 0xe0, 0xca, 0xa4, 0xef, 0xbf, 0x0c, 0xa4, 0x0c, 0x42, 0x58, 0x46,
	0x41, 0x94, 0x64, 0x97, 0x05, 0x3c, 0x28, 0xa0, 0xde, 0x97, 0xc7, 0xb1, 0xcc, 0x78, 0x26, 0x64,
	0x9c, 0x1a, 0xea, 0xfe, 0xb6, 0x48, 0xf3, 0x0c, 0xb8, 0xf2, 0xa6, 0x23, 0xb8, 0xa0, 0x1f, 0xc8,
	0xc6, 0x39, 0x5c, 0x32, 0xab, 0x6d, 0x75, 0x9a, 0x03, 0xf7, 0x7e, 0xee, 0xd8, 0x13, 0xa9, 0xa2,
	0x63, 0xf7, 0x1c, 0x2e, 0xdd, 0xf6, 0x8c, 0x87, 0xc2, 0xe7, 0x19, 0x1c, 0xbb, 0x0a, 0x2e, 0x72,
	0xa1, 0xc0, 0x77, 0x47, 0x3a, 0x9c, 0x0e, 0x49, 0x23, 0xe1, 0x01, 0x9c, 0x89, 0x1f, 0xc0, 0xd6,
	0xdb, 0x56, 0xa7, 0x3e, 0xe8, 0xdf, 0xcd, 0x9d, 0x85, 0x77, 0x3f, 0x77, 0x5c, 0x53, 0xa6, 0x74,
	0xdc, 0xc7, 0x4a, 0x2d, 0xe2, 0xe9, 0x27, 0xb2, 0xa5, 0xd7, 0xc3, 0x3c, 0x62, 0x1b, 0x58, 0xee,
	0xf0, 0x6e, 0xee, 0x94, 0xd6, 0xfd, 0xdc, 0x79, 0xb5, 0xac, 0x36, 0xcc, 0xa3, 0x47, 0x8b, 0x95,
	0xd1, 0xae, 0x4f, 0x48, 0xd9, 0x5e, 0x9a, 0x50, 0x87, 0xd4, 0x3d, 0x99, 0xc7, 0x19, 0x76, 0x58,
	0x1f, 0x34, 0xef, 0xe6, 0x8e, 0x31, 0x46, 0xe6, 0x43, 0x3f, 0x92, 0xba, 0xbe, 0x96, 0x94, 0xad,
	0xb7, 0x37, 0x3a, 0xad, 0xfe, 0x5e, 0x77, 0xf5, 0x62, 0xba, 0x27, 0x2a, 0x0f, 0x4c, 0x1a, 0x86,
	0x8d, 0xcc, 0xc7, 0xfd, 0x4a, 0x1a, 0x27, 0xa8, 0xe1, 0x82, 0x76, 0x2a, 0xd3, 0x30, 0xdb, 0x6c,
	0x57, 0xa7, 0x51, 0xe9, 0xf3, 0xcd, 0xb2, 0x4f, 0x33, 0xb6, 0x56, 0xa5, 0xcf, 0x65, 0x0b, 0x03,
	0xd2, 0x2c, 0x8a, 0xa7, 0xc9, 0xf2, 0x80, 0xd6, 0x7f, 0x1d, 0xf0, 0x57, 0x8d, 0xd4, 0x34, 0xa2,
	0x2f, 0xc8, 0x66, 0x08, 0x33, 0x08, 0x0f, 0xcd, 0xd9, 0x46, 0x85, 0x5a, 0xf8, 0x47, 0xe6, 0x28,
	0x85, 0x7f, 0xb4, 0xf0, 0xfb, 0xe6, 0x2a, 0x0a, 0xbf, 0x4f, 0xdb, 0xa4, 0xf5, 0x6d, 0x2a, 0x43,
	0x48, 0x79, 0x08, 0xa7, 0x3e, 0xab, 0x21, 0xac, 0x5a, 0x74, 0x9f, 0x34, 0xf4, 0xde, 0x43, 0x1e,
	0x01, 0xab, 0xeb, 0x07, 0x35, 0x5a, 0x68, 0x6a, 0x13, 0x92, 0x28, 0x39, 0x13, 0x3e, 0xa8, 0x53,
	0x9f, 0x6d, 0x62, 0x72, 0xc5, 0xa1, 0x2e, 0xd9, 0x2e, 0x15, 0xe6, 0x6f, 0x61, 0xfe, 0x8a, 0x47,
	0x5f, 0x93, 0x9d, 0x34, 0x01, 0x4f, 0x4c, 0x84, 0x87, 0x2f, 0x9a, 0x35, 0x30, 0x68, 0xd5, 0xa4,
	0x94, 0xd4, 0xf2, 0x58, 0x64, 0xac, 0x89, 0x10, 0xd7, 0xba, 0x7a, 0xc4, 0xe3, 0x7c, 0xc2, 0xbd,
	0x2c, 0x57, 0xa0, 0x18, 0x31, 0xd5, 0xab, 0x1e, 0x7d, 0x4b, 0x76, 0x79, 0xa2, 0xf7, 0xe3, 0xe1,
	0x30, 0x8f, 0xc6, 0xa0, 0x58, 0x0b, 0xa3, 0x1e, 0xb8, 0xf4, 0x80, 0x34, 0xf1, 0xfd, 0x9d, 0xf0,
	0x0c, 0xd8, 0x36, 0x86, 0x2c, 0x0d, 0xdd, 0xa7, 0x37, 0xe5, 0x22, 0xfe, 0xac, 0x84, 0x07, 0x6c,
	0x07, 0x71, 0xc5, 0xc1, 0x19, 0x89, 0xd4, 0xd0, 0xdd, 0x62, 0x46, 0x85, 0xd6, 0x2c, 0x2a, 0x33,
	0x9f, 0x18, 0x16, 0x55, 0xf2, 0x22, 0xfe, 0xdd, 0xb0, 0xa7, 0x05, 0x2b, 0xb4, 0x66, 0x32, 0xf4,
	0x0d, 0x7b, 0x66, 0x58, 0xa9, 0xe9, 0x1e, 0xa9, 0x27, 0x08, 0x28, 0x02, 0x23, 0x06, 0x9d, 0xab,
	0x1b, 0x7b, 0xed, 0xfa, 0xc6, 0x5e, 0xbb, 0xba, 0xb5, 0xad, 0xeb, 0x5b, 0xdb, 0xfa, 0x73, 0x6b,
	0x5b, 0x3f, 0xff, 0xda, 0x6b, 0x5f, 0x1e, 0xfc, 0x97, 0xc6, 0x9b, 0xf8, 0xd3, 0x78, 0xff, 0x2f,
	0x00, 0x00, 0xff, 0xff, 0xcf, 0x10, 0xd3, 0xe1, 0xc5, 0x04, 0x00, 0x00,
}

func (m *SearchReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDrug(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDrug(dAtA, i, uint64(m.PageSize))
	}
	if m.PageNum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDrug(dAtA, i, uint64(m.PageNum))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SearchResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDrug(dAtA, i, uint64(m.Count))
	}
	if len(m.Drugs) > 0 {
		for _, msg := range m.Drugs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDrug(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DrugsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DrugsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PageSize != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDrug(dAtA, i, uint64(m.PageSize))
	}
	if m.PageNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDrug(dAtA, i, uint64(m.PageNum))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DrugsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DrugsResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Drugs) > 0 {
		for _, msg := range m.Drugs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDrug(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Drug) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Drug) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDrug(dAtA, i, uint64(m.Level0))
	}
	if m.Level1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDrug(dAtA, i, uint64(m.Level1))
	}
	if m.Level2 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDrug(dAtA, i, uint64(m.Level2))
	}
	if m.WholesaleId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDrug(dAtA, i, uint64(m.WholesaleId))
	}
	if len(m.DrugName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDrug(dAtA, i, uint64(len(m.DrugName)))
		i += copy(dAtA[i:], m.DrugName)
	}
	if m.ProviderId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintDrug(dAtA, i, uint64(m.ProviderId))
	}
	if len(m.ProviderName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintDrug(dAtA, i, uint64(len(m.ProviderName)))
		i += copy(dAtA[i:], m.ProviderName)
	}
	if len(m.Specification) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintDrug(dAtA, i, uint64(len(m.Specification)))
		i += copy(dAtA[i:], m.Specification)
	}
	if len(m.Unit) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintDrug(dAtA, i, uint64(len(m.Unit)))
		i += copy(dAtA[i:], m.Unit)
	}
	if len(m.Manufacturer) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintDrug(dAtA, i, uint64(len(m.Manufacturer)))
		i += copy(dAtA[i:], m.Manufacturer)
	}
	if len(m.ApprovalNumber) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintDrug(dAtA, i, uint64(len(m.ApprovalNumber)))
		i += copy(dAtA[i:], m.ApprovalNumber)
	}
	if len(m.ValidDate) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintDrug(dAtA, i, uint64(len(m.ValidDate)))
		i += copy(dAtA[i:], m.ValidDate)
	}
	if len(m.ChainPrice) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintDrug(dAtA, i, uint64(len(m.ChainPrice)))
		i += copy(dAtA[i:], m.ChainPrice)
	}
	if len(m.DisPrice) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintDrug(dAtA, i, uint64(len(m.DisPrice)))
		i += copy(dAtA[i:], m.DisPrice)
	}
	if len(m.MinPrice) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintDrug(dAtA, i, uint64(len(m.MinPrice)))
		i += copy(dAtA[i:], m.MinPrice)
	}
	if len(m.MaxPrice) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDrug(dAtA, i, uint64(len(m.MaxPrice)))
		i += copy(dAtA[i:], m.MaxPrice)
	}
	if len(m.OldPrice) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDrug(dAtA, i, uint64(len(m.OldPrice)))
		i += copy(dAtA[i:], m.OldPrice)
	}
	if len(m.Price) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDrug(dAtA, i, uint64(len(m.Price)))
		i += copy(dAtA[i:], m.Price)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintDrug(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SearchReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDrug(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovDrug(uint64(m.PageSize))
	}
	if m.PageNum != 0 {
		n += 1 + sovDrug(uint64(m.PageNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SearchResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovDrug(uint64(m.Count))
	}
	if len(m.Drugs) > 0 {
		for _, e := range m.Drugs {
			l = e.Size()
			n += 1 + l + sovDrug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DrugsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PageSize != 0 {
		n += 1 + sovDrug(uint64(m.PageSize))
	}
	if m.PageNum != 0 {
		n += 1 + sovDrug(uint64(m.PageNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DrugsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Drugs) > 0 {
		for _, e := range m.Drugs {
			l = e.Size()
			n += 1 + l + sovDrug(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Drug) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level0 != 0 {
		n += 1 + sovDrug(uint64(m.Level0))
	}
	if m.Level1 != 0 {
		n += 1 + sovDrug(uint64(m.Level1))
	}
	if m.Level2 != 0 {
		n += 1 + sovDrug(uint64(m.Level2))
	}
	if m.WholesaleId != 0 {
		n += 1 + sovDrug(uint64(m.WholesaleId))
	}
	l = len(m.DrugName)
	if l > 0 {
		n += 1 + l + sovDrug(uint64(l))
	}
	if m.ProviderId != 0 {
		n += 1 + sovDrug(uint64(m.ProviderId))
	}
	l = len(m.ProviderName)
	if l > 0 {
		n += 1 + l + sovDrug(uint64(l))
	}
	l = len(m.Specification)
	if l > 0 {
		n += 1 + l + sovDrug(uint64(l))
	}
	l = len(m.Unit)
	if l > 0 {
		n += 1 + l + sovDrug(uint64(l))
	}
	l = len(m.Manufacturer)
	if l > 0 {
		n += 1 + l + sovDrug(uint64(l))
	}
	l = len(m.ApprovalNumber)
	if l > 0 {
		n += 1 + l + sovDrug(uint64(l))
	}
	l = len(m.ValidDate)
	if l > 0 {
		n += 1 + l + sovDrug(uint64(l))
	}
	l = len(m.ChainPrice)
	if l > 0 {
		n += 1 + l + sovDrug(uint64(l))
	}
	l = len(m.DisPrice)
	if l > 0 {
		n += 1 + l + sovDrug(uint64(l))
	}
	l = len(m.MinPrice)
	if l > 0 {
		n += 1 + l + sovDrug(uint64(l))
	}
	l = len(m.MaxPrice)
	if l > 0 {
		n += 2 + l + sovDrug(uint64(l))
	}
	l = len(m.OldPrice)
	if l > 0 {
		n += 2 + l + sovDrug(uint64(l))
	}
	l = len(m.Price)
	if l > 0 {
		n += 2 + l + sovDrug(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDrug(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDrug(x uint64) (n int) {
	return sovDrug(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SearchReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrug
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDrug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageNum", wireType)
			}
			m.PageNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDrug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDrug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drugs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDrug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDrug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Drugs = append(m.Drugs, &Drug{})
			if err := m.Drugs[len(m.Drugs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDrug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDrug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DrugsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DrugsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DrugsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageNum", wireType)
			}
			m.PageNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDrug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDrug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DrugsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DrugsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DrugsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drugs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDrug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDrug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Drugs = append(m.Drugs, &Drug{})
			if err := m.Drugs[len(m.Drugs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDrug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDrug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Drug) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Drug: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Drug: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level0", wireType)
			}
			m.Level0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level0 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level1", wireType)
			}
			m.Level1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level1 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level2", wireType)
			}
			m.Level2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level2 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WholesaleId", wireType)
			}
			m.WholesaleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WholesaleId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrugName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrug
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDrug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DrugName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderId", wireType)
			}
			m.ProviderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProviderId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrug
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDrug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Specification", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrug
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDrug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Specification = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrug
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDrug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manufacturer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrug
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDrug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Manufacturer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrug
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDrug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrug
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDrug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrug
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDrug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrug
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDrug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrug
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDrug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrug
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDrug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrug
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDrug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrug
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDrug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Price = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDrug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrug
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDrug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDrug(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDrug
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDrug
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDrug
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthDrug
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDrug
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDrug(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthDrug
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDrug = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDrug   = fmt.Errorf("proto: integer overflow")
)
