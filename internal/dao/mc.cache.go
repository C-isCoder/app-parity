// Code generated by kratos tool mcgen. DO NOT EDIT.

/*
  Package dao is a generated mc cache package.
  It is generated from:
  type _mc interface {
		// mc: -key=cacheId
		CacheDrugs(c context.Context, sum int32) ([]*pb.Drug, error)
		// mc: -key=noneKey
		CacheNone(c context.Context) (*pb.Drug, error)
		// mc: -key=cacheKey
		CacheString(c context.Context, key string) (string, error)
		// mc: -key=cacheId -expire=d.mcExpire -encode=json
		AddCacheDrugs(c context.Context, sum int32, values []*pb.Drug) error
		// mc: -key=noneKey
		AddCacheNone(c context.Context, value *pb.DrugsResp) error
		// mc: -key=cacheKey -expire=d.mcExpire
		AddCacheString(c context.Context, key string, value string) error

		// mc: -key=cacheId
		DelCacheDrugs(c context.Context, sum int32) error
		// mc: -key=noneKey
		DelCacheNone(c context.Context) error
	}
*/

package dao

import (
	"context"
	"fmt"

	pb "app-parity/api"
	"github.com/bilibili/kratos/pkg/cache/memcache"
	"github.com/bilibili/kratos/pkg/log"
)

var (
	_ _mc
)

// CacheDrugs get data from mc
func (d *Dao) CacheDrugs(c context.Context, id int32) (res []*pb.Drug, err error) {
	key := cacheId(id)
	err = d.mc.Get(c, key).Scan(&res)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("CacheDrugs", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheNone get data from mc
func (d *Dao) CacheNone(c context.Context) (res *pb.Drug, err error) {
	key := noneKey()
	res = &pb.Drug{}
	if err = d.mc.Get(c, key).Scan(res); err != nil {
		res = nil
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
	}
	if err != nil {
		log.Errorv(c, log.KV("CacheNone", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheString get data from mc
func (d *Dao) CacheString(c context.Context, id string) (res string, err error) {
	key := cacheKey(id)
	err = d.mc.Get(c, key).Scan(&res)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("CacheString", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheDrugs Set data to mc
func (d *Dao) AddCacheDrugs(c context.Context, id int32, val []*pb.Drug) (err error) {
	if len(val) == 0 {
		return
	}
	key := cacheId(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcExpire, Flags: memcache.FlagJSON}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheDrugs", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheNone Set data to mc
func (d *Dao) AddCacheNone(c context.Context, val *pb.DrugsResp) (err error) {
	if val == nil {
		return
	}
	key := noneKey()
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcExpire, Flags: memcache.FlagJSON}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheNone", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheString Set data to mc
func (d *Dao) AddCacheString(c context.Context, id string, val string) (err error) {
	if len(val) == 0 {
		return
	}
	key := cacheKey(id)
	bs := []byte(val)
	item := &memcache.Item{Key: key, Value: bs, Expiration: d.mcExpire, Flags: memcache.FlagRAW}
	if err = d.mc.Set(c, item); err != nil {
		log.Errorv(c, log.KV("AddCacheString", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheDrugs delete data from mc
func (d *Dao) DelCacheDrugs(c context.Context, id int32) (err error) {
	key := cacheId(id)
	if err = d.mc.Delete(c, key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("DelCacheDrugs", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheNone delete data from mc
func (d *Dao) DelCacheNone(c context.Context) (err error) {
	key := noneKey()
	if err = d.mc.Delete(c, key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		log.Errorv(c, log.KV("DelCacheNone", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}
